{% extends 'base.html' %}
{% load static %}

{% block title %}Schedle | –ì–ª–∞–≤–Ω–∞—è{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/main_page.css' %}">
<link rel="stylesheet" href="{% static 'css/profile_modal.css' %}">
{% endblock %}

{% block content %}
<div class="main-page-container">
    <nav class="main-page-nav">
        <button class="nav-tab-button active" data-tab="friends">–î—Ä—É–∑—å—è 0</button> {# TODO: Update count dynamically #}
        <button class="nav-tab-button" data-tab="events">–ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è</button>
        <button class="nav-tab-button" data-tab="chats">–ß–∞—Ç—ã</button>
    </nav>

    <div class="main-page-content-wrapper">
        <!-- Left Column -->
        <aside class="main-page-left-column">
            <div class="friend-search-container">
                <input type="text" placeholder="üîç –ü–æ–∏—Å–∫ –≤ –¥—Ä—É–∑—å—è—Ö" class="friend-search-input">
            </div>
            <button class="action-button-mainpage create-group-button">
                <span class="icon-plus-mainpage">+</span> –°–æ–∑–¥–∞—Ç—å –≥—Ä—É–ø–ø—É
            </button>
            <button class="action-button-mainpage friend-requests-button">
                <span class="icon-users-mainpage">üë•</span> –ó–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è
            </button>
            <div class="friends-list-placeholder">
                <p>–î—Ä—É–∑–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ</p> {# TODO: Populate dynamically #}
            </div>

            <!-- Small Calendar Section -->
            <div class="small-calendar-container">
                <div class="calendar-header-mainpage small-calendar-header">
                    <div class="month-year-display">
                        <span id="currentSmallMonth">–ú–µ—Å—è—Ü</span> <span id="currentSmallYear">–ì–æ–¥</span>
                    </div>
                    <div class="calendar-nav-buttons">
                        <button id="prevSmallMonthBtn">&lt;</button>
                        <button id="nextSmallMonthBtn">&gt;</button>
                    </div>
                </div>
                <table class="calendar-grid-mainpage small-calendar-grid">
                    <thead>
                        <tr>
                            <th>–ü–ù</th><th>–í–¢</th><th>–°–†</th><th>–ß–¢</th><th>–ü–¢</th><th>–°–ë</th><th>–í–°</th>
                        </tr>
                    </thead>
                    <tbody id="smallCalendarDaysBody">
                        {# Small calendar days will be populated by JavaScript #}
                    </tbody>
                </table>
            </div>
             <button class="action-button-mainpage view-schedule-button" id="viewScheduleBtn">
                üóìÔ∏è –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å/–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ
            </button>
            <button class="action-button-mainpage create-event-general-button" id="createEventGeneralBtn">
                ‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ
            </button>
        </aside>
        <div class="resizer" id="resizer-left-center"></div>
        
        <!-- Center Column (Main Content - initially might be empty or show other tab content) -->
        <main class="main-page-center-column">
            <!-- This area will be for general content, or can be hidden/resized
                 when timeline view is active if timeline takes full space -->
            <p>–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∫–æ–ª–æ–Ω–∫–∞. –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –±—É–¥–µ—Ç –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–π –≤–∫–ª–∞–¥–∫–∏ –∏–ª–∏ –¥–µ–π—Å—Ç–≤–∏—è.</p>
            
        </main>
        <div class="resizer" id="resizer-center-right"></div>

        <!-- Right Column (Timeline View) -->
        <aside class="main-page-right-column" id="timelineViewContainer">
            <!-- Timeline will be dynamically generated here by JavaScript -->
            <!-- Example of how it might look (structure from image) -->
            <!--
            <div class="timeline-day-entry">
                <div class="timeline-day-label">1 –ü–ù</div>
                <div class="timeline-day-content">
                    <div class="timeline-event-placeholder">–ù–µ—Ç —Å–æ–±—ã—Ç–∏–π –Ω–∞ –¥–µ–Ω—å</div>
                </div>
            </div>
            -->
        </aside>
    </div>
</div>

<!-- Profile Modal (Preserved) -->
<div class="modal" id="profileModal" style="display: none;">
    <div class="modal-content"> {# Ensure .modal-content wraps the actual content for sizing #}
        <div class="modal-header">
            <h2 class="modal-title">–ü—Ä–æ—Ñ–∏–ª—å</h2>
            <button class="close-button" id="profileModalCloseButton">&times;</button>
        </div>
        
        <form method="POST" action="{% url 'edit_profile' %}" enctype="multipart/form-data">
            {% csrf_token %}
            <div class="profile-view-main-info">
                {% if user_profile.profile_picture %}
                    <img src="{{ user_profile.profile_picture.url }}" alt="–§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è" class="profile-photo-display">
                {% else %}
                    <img src="{% static 'images/default_avatar.png' %}" alt="–§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è" class="profile-photo-display" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                    <div class="profile-photo-default-circle"></div>
                {% endif %}
                <div class="profile-text-info">
                    <p class="profile-name">{{ user.get_full_name|default:user.username }}</p>
                    <p class="profile-username">@{{ user.username }}</p>
                    <p class="profile-email">{{ user.email }}</p>
                </div>
                <a href="#" id="editProfileLink" class="edit-profile-link">‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å</a>
            </div>
            
            <div id="profileEditForm" style="display: none;">
                <h4>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é</h4>
                <div class="profile-edit-field">
                    <label for="profile_pic_input">–§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è:</label>
                    <input type="file" name="profile_picture" accept="image/*" id="profile_pic_input">
                </div>
                <div class="profile-edit-field">
                    <label for="first_name_input">–ò–º—è:</label>
                    <input type="text" value="{{ user.first_name }}" name="first_name" id="first_name_input">
                </div>
                <div class="profile-edit-field">
                    <label for="last_name_input">–§–∞–º–∏–ª–∏—è:</label>
                    <input type="text" value="{{ user.last_name }}" name="last_name" id="last_name_input">
                </div>
                <div class="profile-edit-field">
                    <label for="email_input">Email:</label>
                    <input type="email" value="{{ user.email }}" name="email" id="email_input">
                </div>
            </div>

            <div class="profile-section-divider">–ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å</div>
            <div class="profile-settings-list">
                <div class="profile-field">
                    <span>–ö—Ç–æ –≤–∏–¥–∏—Ç –ª–∏—á–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ</span>
                    <a href="#" class="profile-field-value" data-setting="privacy_schedule_visibility">{{ user_profile.get_privacy_schedule_visibility_display }}</a>
                </div>
                <div class="profile-field">
                    <span>–ö—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≥–ª–∞—à–∞—Ç—å –Ω–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è</span>
                    <a href="#" class="profile-field-value" data-setting="privacy_can_invite_to_event">{{ user_profile.get_privacy_can_invite_to_event_display }}</a>
                </div>
                <div class="profile-field">
                    <span>–ö—Ç–æ –º–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è</span>
                    <a href="#" class="profile-field-value" data-setting="privacy_can_send_message">{{ user_profile.get_privacy_can_send_message_display }}</a>
                </div>
                <div class="profile-field">
                    <span>–ö—Ç–æ –≤–∏–¥–∏—Ç —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è</span>
                    <a href="#" class="profile-field-value" data-setting="privacy_profile_photo_visibility">{{ user_profile.get_privacy_profile_photo_visibility_display }}</a>
                </div>
            </div>
            
            <div id="privacyEditForm" style="display: none;">
                <h4>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏</h4>
                <div class="profile-edit-field">
                    <label for="id_privacy_schedule_visibility">–ö—Ç–æ –≤–∏–¥–∏—Ç –ª–∏—á–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ:</label>
                    <select name="privacy_schedule_visibility" id="id_privacy_schedule_visibility">
                        {% for value, text in user_profile.PRIVACY_CHOICES %}
                        <option value="{{ value }}" {% if user_profile.privacy_schedule_visibility == value %}selected{% endif %}>{{ text }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="profile-edit-field">
                    <label for="id_privacy_can_invite_to_event">–ö—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≥–ª–∞—à–∞—Ç—å –Ω–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è:</label>
                    <select name="privacy_can_invite_to_event" id="id_privacy_can_invite_to_event">
                         {% for value, text in user_profile.PRIVACY_CHOICES %}{% if value != 'only_me' %}
                        <option value="{{ value }}" {% if user_profile.privacy_can_invite_to_event == value %}selected{% endif %}>{{ text }}</option>
                        {% endif %}{% endfor %}
                    </select>
                </div>
                <div class="profile-edit-field">
                    <label for="id_privacy_can_send_message">–ö—Ç–æ –º–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è:</label>
                    <select name="privacy_can_send_message" id="id_privacy_can_send_message">
                        {% for value, text in user_profile.PRIVACY_CHOICES %}{% if value != 'only_me' %}
                        <option value="{{ value }}" {% if user_profile.privacy_can_send_message == value %}selected{% endif %}>{{ text }}</option>
                        {% endif %}{% endfor %}
                    </select>
                </div>
                <div class="profile-edit-field">
                    <label for="id_privacy_profile_photo_visibility">–ö—Ç–æ –≤–∏–¥–∏—Ç —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è:</label>
                    <select name="privacy_profile_photo_visibility" id="id_privacy_profile_photo_visibility">
                        {% for value, text in user_profile.PRIVACY_CHOICES %}
                        <option value="{{ value }}" {% if user_profile.privacy_profile_photo_visibility == value %}selected{% endif %}>{{ text }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <div class="profile-section-divider">–û—Å—Ç–∞–ª—å–Ω–æ–µ</div>
            <div class="profile-settings-list">
                <div class="profile-field">
                    <span>–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</span>
                    <a href="#" class="profile-field-value" data-setting="interface_language">{{ user_profile.interface_language }}</a>
                </div>
            </div>
            
            <div id="languageEditForm" style="display:none;">
              <h4>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —è–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</h4>
               <div class="profile-edit-field">
                    <label for="id_interface_language">–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞:</label>
                    <select name="interface_language" id="id_interface_language">
                        <option value="–†—É—Å—Å–∫–∏–π" {% if user_profile.interface_language == "–†—É—Å—Å–∫–∏–π" %}selected{% endif %}>–†—É—Å—Å–∫–∏–π</option>
                        <option value="English" {% if user_profile.interface_language == "English" %}selected{% endif %}>English</option>
                    </select>
                </div>
            </div>
            
            <div class="profile-actions">
                <button type="submit" id="saveProfileButton" class="action-button" style="display:none;">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è</button>
                <a href="{% url 'logout' %}" class="profile-action">–í—ã–π—Ç–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞</a>
                <a href="#" class="profile-action danger">–£–¥–∞–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç</a> {# TODO: Implement delete account functionality #}
            </div>
        </form>
    </div>
</div>

<!-- Event Modal (for creating/editing events) -->
<div class="modal" id="eventModal" style="display: none;">
    <div class="modal-content"> {# Ensure .modal-content wraps the actual content for sizing #}
        <div class="modal-header">
            <h2 class="modal-title" id="eventModalTitle">–°–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ</h2>
            <button class="close-button" id="eventModalCloseButton">&times;</button>
        </div>
        <form method="POST" id="eventForm"> 
            {% csrf_token %}
            <input type="hidden" name="event_id" id="event_id">
            
            <div class="profile-edit-field">
                <label for="id_Title">–ù–∞–∑–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è:</label>
                {{ event_form.Title }}
            </div>
            <div class="profile-edit-field">
                <label for="id_StartTime">–í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞:</label>
                {{ event_form.StartTime }}
            </div>
            <div class="profile-edit-field">
                <label for="id_EndTime">–í—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è:</label>
                {{ event_form.EndTime }}
            </div>
            <div class="profile-edit-field">
                <label for="id_Description">–û–ø–∏—Å–∞–Ω–∏–µ:</label>
                {{ event_form.Description }}
            </div>
            <div class="profile-edit-field">
                <label for="id_event_type">–¢–∏–ø —Å–æ–±—ã—Ç–∏—è:</label>
                {{ event_form.event_type }}
            </div>
            <div class="profile-edit-field">
                <label for="id_Colour">–¶–≤–µ—Ç (hex):</label>
                {{ event_form.Colour }}
            </div>
            <div class="profile-actions" style="margin-top: 20px;">
                <button type="submit" class="action-button">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ</button>
            </div>
        </form>
    </div>
</div>

{% endblock %}

{% block extra_js %}
  <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Profile modal functionality (Preserved)
        const profileButton = document.getElementById('headerProfileIcon');
        const profileModal = document.getElementById('profileModal');
        const profileModalCloseButton = document.getElementById('profileModalCloseButton');
        const editProfileLink = document.getElementById('editProfileLink');
        const profileViewMainInfo = document.querySelector('.profile-view-main-info');
        const profileEditForm = document.getElementById('profileEditForm');
        const privacyEditForm = document.getElementById('privacyEditForm');
        const languageEditForm = document.getElementById('languageEditForm');
        const saveProfileButton = document.getElementById('saveProfileButton');

        if (profileButton) {
            profileButton.addEventListener('click', () => {
                if (profileModal) profileModal.style.display = 'flex'; // Use flex for centering
                if (profileViewMainInfo) profileViewMainInfo.style.display = ''; 
                if (profileEditForm) profileEditForm.style.display = 'none';
                if (privacyEditForm) privacyEditForm.style.display = 'none';
                if (languageEditForm) languageEditForm.style.display = 'none';
                if (saveProfileButton) saveProfileButton.style.display = 'none';
                if (editProfileLink) editProfileLink.textContent = '‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å';
                document.querySelectorAll('.profile-settings-list').forEach(list => list.style.display = '');
            });
        }
        if (profileModalCloseButton) {
            profileModalCloseButton.addEventListener('click', () => {
                if (profileModal) profileModal.style.display = 'none';
            });
        }
        if (editProfileLink) {
            editProfileLink.addEventListener('click', (e) => {
                e.preventDefault();
                const isEditing = profileEditForm && profileEditForm.style.display !== 'none';
                if (isEditing) {
                    if (profileViewMainInfo) profileViewMainInfo.style.display = '';
                    if (profileEditForm) profileEditForm.style.display = 'none';
                    if (privacyEditForm) privacyEditForm.style.display = 'none';
                    if (languageEditForm) languageEditForm.style.display = 'none';
                    if (saveProfileButton) saveProfileButton.style.display = 'none';
                    editProfileLink.textContent = '‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å';
                    document.querySelectorAll('.profile-settings-list').forEach(list => list.style.display = '');
                } else {
                    if (profileViewMainInfo) profileViewMainInfo.style.display = 'none';
                    if (profileEditForm) profileEditForm.style.display = 'block';
                    if (privacyEditForm) privacyEditForm.style.display = 'block';
                    if (languageEditForm) languageEditForm.style.display = 'block';
                    if (saveProfileButton) saveProfileButton.style.display = 'block';
                    editProfileLink.textContent = '‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞';
                    document.querySelectorAll('.profile-settings-list').forEach(list => list.style.display = 'none');
                }
            });
        }

        // Small Calendar Functionality (NEW)
        const currentSmallMonthEl = document.getElementById('currentSmallMonth');
        const currentSmallYearEl = document.getElementById('currentSmallYear');
        const smallCalendarDaysBodyEl = document.getElementById('smallCalendarDaysBody');
        const prevSmallMonthBtn = document.getElementById('prevSmallMonthBtn');
        const nextSmallMonthBtn = document.getElementById('nextSmallMonthBtn');
        let currentSmallCalendarDate = new Date(); // Separate date object for small calendar

        let selectedStartDate = null;
        let selectedEndDate = null;

        const monthNames = ["–Ø–Ω–≤–∞—Ä—å", "–§–µ–≤—Ä–∞–ª—å", "–ú–∞—Ä—Ç", "–ê–ø—Ä–µ–ª—å", "–ú–∞–π", "–ò—é–Ω—å",
                            "–ò—é–ª—å", "–ê–≤–≥—É—Å—Ç", "–°–µ–Ω—Ç—è–±—Ä—å", "–û–∫—Ç—è–±—Ä—å", "–ù–æ—è–±—Ä—å", "–î–µ–∫–∞–±—Ä—å"];

        function renderSmallCalendar() {
            const year = currentSmallCalendarDate.getFullYear();
            const month = currentSmallCalendarDate.getMonth();

            if (currentSmallMonthEl) currentSmallMonthEl.textContent = monthNames[month];
            if (currentSmallYearEl) currentSmallYearEl.textContent = year;
            
            if (!smallCalendarDaysBodyEl) return;
            smallCalendarDaysBodyEl.innerHTML = ''; 

            const firstDayOfMonth = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            let startingDay = (firstDayOfMonth === 0) ? 6 : firstDayOfMonth - 1;
            const daysInPrevMonth = new Date(year, month, 0).getDate();
            let date = 1;
            let nextMonthDate = 1;

            for (let i = 0; i < 6; i++) {
                const row = document.createElement('tr');
                for (let j = 0; j < 7; j++) {
                    const cell = document.createElement('td');
                    cell.classList.add('calendar-day-mainpage'); // Can reuse some styling
                    const dateNumberSpan = document.createElement('span');
                    dateNumberSpan.classList.add('date-number');

                    let cellDateStr = '';
                    if (i === 0 && j < startingDay) {
                        dateNumberSpan.textContent = daysInPrevMonth - startingDay + j + 1;
                        cell.classList.add('other-month');
                    } else if (date > daysInMonth) {
                        dateNumberSpan.textContent = nextMonthDate++;
                        cell.classList.add('other-month');
                    } else {
                        dateNumberSpan.textContent = date;
                        if (date === new Date().getDate() && year === new Date().getFullYear() && month === new Date().getMonth()) {
                            cell.classList.add('today-mainpage');
                        }
                        cellDateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(date).padStart(2, '0')}`;
                        cell.dataset.date = cellDateStr;
                        
                        // Highlight selected dates
                        if (selectedStartDate && cellDateStr === selectedStartDate) cell.classList.add('selected-start');
                        if (selectedEndDate && cellDateStr === selectedEndDate) cell.classList.add('selected-end');
                        if (selectedStartDate && selectedEndDate && cellDateStr > selectedStartDate && cellDateStr < selectedEndDate) {
                            cell.classList.add('selected-range');
                        }

                        cell.addEventListener('click', function() {
                            const clickedDate = this.dataset.date;
                            if (!selectedStartDate || (selectedStartDate && selectedEndDate)) {
                                // Start new selection or restart after range is complete
                                selectedStartDate = clickedDate;
                                selectedEndDate = null;
                                console.log("Selected start:", selectedStartDate);
                            } else if (selectedStartDate && !selectedEndDate) {
                                // If start is selected, select end date
                                if (clickedDate < selectedStartDate) { // If end is before start, make clicked the new start
                                    selectedEndDate = selectedStartDate;
                                    selectedStartDate = clickedDate;
                                } else {
                                    selectedEndDate = clickedDate;
                                }
                                console.log("Selected end:", selectedEndDate);
                                // Optionally, automatically generate timeline here if you want it after 2 clicks
                                // generateTimelineView(new Date(selectedStartDate), new Date(selectedEndDate)); 
                            }
                            renderSmallCalendar(); // Re-render to show selection highlights
                        });
                        date++;
                    }
                    cell.appendChild(dateNumberSpan); // Only add date number, no event wrapper
                    row.appendChild(cell);
                }
                smallCalendarDaysBodyEl.appendChild(row);
                if (date > daysInMonth && i >= Math.floor((startingDay + daysInMonth -1) / 7) ) break;
            }
            // No event fetching for small calendar, it's for navigation/selection
        }

        if (prevSmallMonthBtn) {
            prevSmallMonthBtn.addEventListener('click', () => {
                currentSmallCalendarDate.setMonth(currentSmallCalendarDate.getMonth() - 1);
                renderSmallCalendar();
            });
        }
        if (nextSmallMonthBtn) {
            nextSmallMonthBtn.addEventListener('click', () => {
                currentSmallCalendarDate.setMonth(currentSmallCalendarDate.getMonth() + 1);
                renderSmallCalendar();
            });
        }
        if (smallCalendarDaysBodyEl) { // Initial render if element exists
             renderSmallCalendar();
        }

        // Timeline View Generation (NEW - Placeholder, to be expanded)
        const viewScheduleButton = document.getElementById('viewScheduleBtn');
        const timelineViewContainer = document.getElementById('timelineViewContainer');
        const centerColumnEl = document.querySelector('.main-page-center-column'); // Get center column
        const resizerCenterRightEl = document.getElementById('resizer-center-right'); // Get resizer

        function generateTimelineView(startDate, endDate) {
            if (!timelineViewContainer) return;
            timelineViewContainer.innerHTML = ''; 

            if (!startDate || !endDate) {
                // This alert was removed in a previous step, user confirmed selection is required
                // alert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –Ω–∞—á–∞–ª—å–Ω—É—é –∏ –∫–æ–Ω–µ—á–Ω—É—é –¥–∞—Ç—É –Ω–∞ –º–∞–ª–µ–Ω—å–∫–æ–º –∫–∞–ª–µ–Ω–¥–∞—Ä–µ.");
                // Defaulting to a 7-day range if nothing is selected (or only start)
                // This path should ideally not be hit if button logic requires selection.
                const todayForTimeline = new Date();
                const sevenDaysLaterForTimeline = new Date();
                sevenDaysLaterForTimeline.setDate(todayForTimeline.getDate() + 6);
                startDate = startDate || todayForTimeline; // Use provided startDate if available
                endDate = endDate || sevenDaysLaterForTimeline; // Use provided endDate if available
            }
            
            // Hide center column and its resizer, make timeline (right column) visible and effectively expand
            if (centerColumnEl) centerColumnEl.style.display = 'none';
            if (resizerCenterRightEl) resizerCenterRightEl.style.display = 'none';
            if (timelineViewContainer) timelineViewContainer.style.display = 'flex';

            let currentDate = new Date(startDate); 
            currentDate.setHours(0,0,0,0); // Ensure currentDate starts at the beginning of the day
            
            let processingEndDate = new Date(endDate); 
            processingEndDate.setHours(23, 59, 59, 999); // Set to end of the selected day for comparison

            console.log(`Timeline loop: currentDate starts at ${currentDate.toISOString()}, processingEndDate is ${processingEndDate.toISOString()}`);

            while (currentDate <= processingEndDate) {
                const dayEntry = document.createElement('div');
                dayEntry.classList.add('timeline-day-entry');

                const dayLabel = document.createElement('div');
                dayLabel.classList.add('timeline-day-label');
                const dayNamesShort = ['–í–°', '–ü–ù', '–í–¢', '–°–†', '–ß–¢', '–ü–¢', '–°–ë'];
                dayLabel.textContent = `${currentDate.getDate()} ${dayNamesShort[currentDate.getDay()]}`;
                dayLabel.dataset.date = currentDate.toISOString().split('T')[0]; // Store date for click

                dayLabel.addEventListener('click', function() {
                    openEventModal(this.dataset.date); // Create event for this day
                });
                
                const dayContent = document.createElement('div');
                dayContent.classList.add('timeline-day-content');
                
                // Store the date on the dayContent element for easy access on click (REMOVING THIS LISTENER)
                // dayContent.dataset.date = currentDate.toISOString().split('T')[0]; 
                // dayContent.addEventListener('click', function(e) {
                //     if (e.target === this) { 
                //         openEventModal(this.dataset.date);
                //     }
                // });

                dayEntry.appendChild(dayLabel);
                dayEntry.appendChild(dayContent);
                timelineViewContainer.appendChild(dayEntry);

                // Fetch and display events for this specific day
                // Pass a new Date object to avoid modification issues if currentDate is mutated elsewhere by async calls
                fetchAndDisplayEventsForTimelineDay(new Date(currentDate), dayContent);

                currentDate.setDate(currentDate.getDate() + 1); 
                currentDate.setHours(0,0,0,0); // Ensure time is reset for the next iteration
            }
        }

        async function fetchAndDisplayEventsForTimelineDay(dateObj, dayContentElement) {
            const year = dateObj.getFullYear();
            const month = dateObj.getMonth() + 1; // JS months are 0-indexed
            const day = dateObj.getDate();

            dayContentElement.innerHTML = '<div class="timeline-event-placeholder">–ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ–±—ã—Ç–∏–π...</div>'; // Loading state

            try {
                const response = await fetch(`/get_day_events/${year}/${month}/${day}/`);
                if (!response.ok) {
                    console.error(`Failed to fetch events for ${year}-${month}-${day}:`, response.status);
                    dayContentElement.innerHTML = '<div class="timeline-event-placeholder" style="color: red;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–±—ã—Ç–∏–π</div>';
                    return;
                }
                const events = await response.json();

                // If no events, display placeholder and return
                if (events.length === 0) {
                    dayContentElement.innerHTML = '<div class="timeline-event-placeholder">–ù–µ—Ç —Å–æ–±—ã—Ç–∏–π –Ω–∞ –¥–µ–Ω—å</div>';
                    return;
                }

                // Clear loading/placeholder ONLY if there are events to process
                dayContentElement.innerHTML = ''; 

                let eventTopOffset = 0; 
                const eventHeight = 22; 
                const eventMargin = 2; 

                events.forEach(event => {
                    console.log(`Processing Event: ${event.title} for day ${dateObj.toDateString()}`); // DEBUG
                    console.log(`  Event color from server: '${event.color}'`); // ADDED: Log the fetched color
                    const eventItem = document.createElement('div');
                    eventItem.classList.add('timeline-event-item'); 
                    eventItem.style.backgroundColor = event.color || '#777'; // CHANGED: Brighter fallback color
                    
                    const originalEventStart = new Date(event.start);
                    const originalEventEnd = new Date(event.end);

                    // Determine actual start and end times for *this specific day* (dateObj)
                    let dayBoundaryStart = new Date(dateObj); // This is the specific day being rendered
                    dayBoundaryStart.setHours(0, 0, 0, 0);
                    let dayBoundaryEnd = new Date(dateObj);
                    dayBoundaryEnd.setHours(23, 59, 59, 999);

                    // Effective start time for rendering on this day
                    let displayStartTimeOnDay = originalEventStart > dayBoundaryStart ? originalEventStart : dayBoundaryStart;
                    // Effective end time for rendering on this day
                    let displayEndTimeOnDay = originalEventEnd < dayBoundaryEnd ? originalEventEnd : dayBoundaryEnd;

                    // --- BEGIN DETAILED DATE LOGGING ---
                    console.log(`  DEBUG DATES for event: ${event.title} on ${dateObj.toDateString()}`);
                    console.log(`    dateObj (local for day): ${dateObj.toString()}`);
                    console.log(`    originalEventStart (ISO): ${originalEventStart.toISOString()}, originalEventStart (local): ${originalEventStart.toString()}`);
                    console.log(`    originalEventEnd (ISO): ${originalEventEnd.toISOString()}, originalEventEnd (local): ${originalEventEnd.toString()}`);
                    console.log(`    dayBoundaryStart (ISO): ${dayBoundaryStart.toISOString()}, dayBoundaryStart (local): ${dayBoundaryStart.toString()}`);
                    console.log(`    dayBoundaryEnd (ISO): ${dayBoundaryEnd.toISOString()}, dayBoundaryEnd (local): ${dayBoundaryEnd.toString()}`);
                    console.log(`    displayStartTimeOnDay (ISO): ${displayStartTimeOnDay.toISOString()}, displayStartTimeOnDay (local): ${displayStartTimeOnDay.toString()}`);
                    console.log(`    displayEndTimeOnDay (ISO): ${displayEndTimeOnDay.toISOString()}, displayEndTimeOnDay (local): ${displayEndTimeOnDay.toString()}`);
                    // --- END DETAILED DATE LOGGING ---

                    // If event doesn't actually fall on this day after clamping, skip
                    if (displayStartTimeOnDay > displayEndTimeOnDay) { // This check uses full Date objects, should be fine
                        console.log(`  Event ${event.title} SKIPPED for ${dateObj.toDateString()}: displayStartTimeOnDay > displayEndTimeOnDay`); 
                        return; 
                    }
                    
                    const dayTotalMinutes = 24 * 60;

                    // Use UTC hours/minutes for positioning to match apparent time from server
                    let eventStartMinutesOnDay = (displayStartTimeOnDay.getUTCHours() * 60) + displayStartTimeOnDay.getUTCMinutes();
                    let eventEndMinutesOnDay = (displayEndTimeOnDay.getUTCHours() * 60) + displayEndTimeOnDay.getUTCMinutes();
                    
                    if (displayEndTimeOnDay.getUTCHours() === 23 && 
                        displayEndTimeOnDay.getUTCMinutes() === 59 && 
                        displayEndTimeOnDay.getUTCSeconds() >= 59) { 
                        eventEndMinutesOnDay = dayTotalMinutes;
                    }

                    const eventDurationMinutesOnDay = Math.max(0, eventEndMinutesOnDay - eventStartMinutesOnDay);
                    console.log(`  Event Minutes on Day (using UTC components): Start=${eventStartMinutesOnDay}, End=${eventEndMinutesOnDay}, Duration=${eventDurationMinutesOnDay}`);

                    const isAllDayForThisCell = (originalEventStart <= dayBoundaryStart && originalEventEnd >= dayBoundaryEnd);

                    if (eventDurationMinutesOnDay > 0 || isAllDayForThisCell) { 
                        let currentLeftPercentage, currentWidthPercentage;
                        if (isAllDayForThisCell) {
                             eventItem.style.left = '0%';
                             eventItem.style.width = '100%';
                             currentLeftPercentage = 0; currentWidthPercentage = 100;
                        } else {
                            currentLeftPercentage = (eventStartMinutesOnDay / dayTotalMinutes) * 100;
                            currentWidthPercentage = (eventDurationMinutesOnDay / dayTotalMinutes) * 100;
                            eventItem.style.left = `${currentLeftPercentage}%`;
                            eventItem.style.width = `${Math.max(currentWidthPercentage, 2)}%`;
                        }
                        console.log(`  Applied Styles: Left=${eventItem.style.left}, Width=${eventItem.style.width}, Top=${eventTopOffset}px, BG=${event.color || '#777'}`);
                        
                        eventItem.style.top = `${eventTopOffset}px`;
                        eventTopOffset += eventHeight + eventMargin; 

                        const eventTime = document.createElement('span');
                        eventTime.classList.add('timeline-event-time');
                        if (isAllDayForThisCell) {
                            eventTime.textContent = "–í–µ—Å—å –¥–µ–Ω—å";
                        } else {
                            // Format UTC time for display
                            const startHoursUTC = String(displayStartTimeOnDay.getUTCHours()).padStart(2, '0');
                            const startMinutesUTC = String(displayStartTimeOnDay.getUTCMinutes()).padStart(2, '0');
                            const endHoursUTC = String(displayEndTimeOnDay.getUTCHours()).padStart(2, '0');
                            const endMinutesUTC = String(displayEndTimeOnDay.getUTCMinutes()).padStart(2, '0');
                            eventTime.textContent = `${startHoursUTC}:${startMinutesUTC} - ${endHoursUTC}:${endMinutesUTC}`;
                        }

                        const eventTitle = document.createElement('span');
                        eventTitle.classList.add('timeline-event-title');
                        eventTitle.textContent = event.title;

                        eventItem.appendChild(eventTitle);
                        eventItem.appendChild(eventTime);
                        
                        eventItem.dataset.eventId = event.id;
                        eventItem.addEventListener('click', () => {
                            openEventModalForEdit(event.id);
                        });
                        dayContentElement.appendChild(eventItem);
                    } else {
                        console.log(`  Event ${event.title} NOT RENDERED for ${dateObj.toDateString()} (duration ${eventDurationMinutesOnDay}, not all day)`); // DEBUG
                    }
                });

                // After looping, if no event items were actually added, show placeholder
                if (dayContentElement.children.length === 0) {
                    dayContentElement.innerHTML = '<div class="timeline-event-placeholder">–ù–µ—Ç —Å–æ–±—ã—Ç–∏–π –Ω–∞ –¥–µ–Ω—å</div>';
                }

            } catch (error) {
                console.error(`Error fetching or displaying events for ${year}-${month}-${day}:`, error);
                dayContentElement.innerHTML = '<div class="timeline-event-placeholder" style="color: red;">–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ —Å–æ–±—ã—Ç–∏–π</div>';
            }
        }

        if (viewScheduleButton) {
            viewScheduleButton.addEventListener('click', () => {
                if (selectedStartDate && selectedEndDate) {
                    console.log(`Calling generateTimelineView with startDate: ${selectedStartDate}, endDate: ${selectedEndDate}`);
                    generateTimelineView(new Date(selectedStartDate), new Date(selectedEndDate));
                } else if (selectedStartDate) {
                    alert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏ –∫–æ–Ω–µ—á–Ω—É—é –¥–∞—Ç—É –Ω–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ.");
                    console.log(`Calling generateTimelineView (single day) with startDate: ${selectedStartDate}, endDate: ${selectedStartDate}`);
                    generateTimelineView(new Date(selectedStartDate), new Date(selectedStartDate)); 
                } else {
                    alert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –Ω–∞—á–∞–ª—å–Ω—É—é –∏ –∫–æ–Ω–µ—á–Ω—É—é –¥–∞—Ç—É –Ω–∞ –º–∞–ª–µ–Ω—å–∫–æ–º –∫–∞–ª–µ–Ω–¥–∞—Ä–µ –∏–ª–∏ —Ö–æ—Ç—è –±—ã –Ω–∞—á–∞–ª—å–Ω—É—é.");
                }
            });
        }
        
        // TODO: Add logic to show center column and resizer again when navigating away from timeline view
        // For example, when clicking other main nav tabs.
        // E.g., document.querySelectorAll('.nav-tab-button').forEach(tab => {
        //    tab.addEventListener('click', () => {
        //        if (centerColumnEl) centerColumnEl.style.display = 'flex'; // or 'block' depending on original
        //        if (resizerCenterRightEl) resizerCenterRightEl.style.display = 'flex'; // or 'block'
        //        if (timelineViewContainer) timelineViewContainer.innerHTML = ''; // Clear timeline
        //    });
        // });
        
        // OLD Calendar Functionality (fetchAndDisplayEvents, openEventModal, openEventModalForEdit)
        // This will need to be adapted or removed if the main large calendar is gone.
        // For now, I will comment it out to avoid conflicts, assuming the new timeline view
        // will have its own event display and interaction logic.

        /*
        const currentMonthEl = document.getElementById('currentMonth'); // These might be null now
        const currentYearEl = document.getElementById('currentYear');
        const calendarDaysBodyEl = document.getElementById('calendarDaysBody');
        const prevMonthBtn = document.getElementById('prevMonthBtn');
        const nextMonthBtn = document.getElementById('nextMonthBtn');
        const timelineMonthHeaderEl = document.getElementById('timelineMonthHeader'); 
        let currentDate = new Date(); // This was for the large calendar

        function renderCalendar() { ... } // Old renderCalendar
        async function fetchAndDisplayEvents(year, month_one_indexed, calendarCells) { ... } // Old event fetching
        // Event Modal functions (openEventModal, openEventModalForEdit) might still be useful
        // but will be triggered from the timeline view, not the old large calendar.
        */

        // Event Modal Functionality (Preserved, but trigger points will change)
        const eventModal = document.getElementById('eventModal');
        const eventModalCloseButton = document.getElementById('eventModalCloseButton');
        const eventForm = document.getElementById('eventForm');
        const eventModalTitle = document.getElementById('eventModalTitle');
        const eventIdInput = document.getElementById('event_id');

        if (eventForm) {
            eventForm.addEventListener('submit', async function(e) {
                e.preventDefault(); // Prevent default page reload

                const formData = new FormData(this);
                const url = this.action;

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'X-CSRFToken': formData.get('csrfmiddlewaretoken') // Ensure CSRF token is sent
                        }
                    });

                    // After form submission (create or edit), close modal and refresh timeline
                    if (eventModal) eventModal.style.display = 'none';

                    // Response.url will be the URL after redirects. If it's the main page, 
                    // it implies a successful operation (or at least one that the backend processed and redirected from).
                    // A more robust check would involve the backend returning JSON for AJAX calls.
                    if (response.redirected && response.url.endsWith('/')) { // Assuming main_page is at root '/'
                         // We should check if the redirect URL is the main page URL
                        const mainPageUrl = new URL('{% url "main_page" %}', window.location.origin).href;
                        if (response.url === mainPageUrl) {
                             if (selectedStartDate && selectedEndDate) {
                                console.log("Refreshing timeline for", selectedStartDate, "to", selectedEndDate);
                                generateTimelineView(new Date(selectedStartDate), new Date(selectedEndDate));
                            } else if (selectedStartDate) { // If only start was selected (e.g. single day view)
                                console.log("Refreshing timeline for single day", selectedStartDate);
                                generateTimelineView(new Date(selectedStartDate), new Date(selectedStartDate));
                            }
                        } else {
                            // If redirected elsewhere, or an error occurred that didn't redirect to main_page
                            // a full page reload might be what the backend intended for that case.
                            // Or, ideally backend returns JSON error messages for AJAX.
                            console.warn("Form submission redirected to an unexpected URL or failed without redirect to main page.", response);
                            // Potentially reload or show a generic error to user
                        }
                    } else if (response.ok) {
                        // This case might be hit if the backend is changed to return JSON on success for AJAX
                        // and NOT redirect. For now, we assume redirects.
                        console.log("Form submitted successfully (non-redirect response).");
                         if (selectedStartDate && selectedEndDate) {
                            generateTimelineView(new Date(selectedStartDate), new Date(selectedEndDate));
                        }
                    } else {
                        // Handle HTTP errors if the fetch itself failed or backend returned an error status without redirect
                        console.error("Event form submission failed:", response.status, response.statusText);
                        alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Å–æ–±—ã—Ç–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å.");
                    }
                } catch (error) {
                    console.error("Error submitting event form:", error);
                    alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–∞–Ω–Ω—ã—Ö —Å–æ–±—ã—Ç–∏—è.");
                }
            });
        }

        function openEventModal(dateString = null) {
            // ... (definition as before, but ensure dateString can be passed from timeline)
            if (!eventModal || !eventForm) return;
            eventForm.reset(); 
            if (eventIdInput) eventIdInput.value = ''; 
            if (eventModalTitle) eventModalTitle.textContent = '–°–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ';
            
            if (dateString) { // dateString should be YYYY-MM-DD
                const startTimeField = eventForm.querySelector('[name="StartTime"]');
                if (startTimeField) {
                    startTimeField.value = `${dateString}T09:00`; 
                }
            }
            eventForm.action = "{% url 'create_event' %}";
            eventModal.style.display = 'block';
        }

        async function openEventModalForEdit(eventId) {
            // ... (definition as before)
            if (!eventModal || !eventForm) return;
            // ... rest of the function
             try {
                const response = await fetch(`/get_event_details/${eventId}/`);
                if (!response.ok) {
                    console.error("Failed to fetch event details:", response.status);
                    alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è.");
                    return;
                }
                const eventData = await response.json();

                eventForm.reset();
                if (eventModalTitle) eventModalTitle.textContent = '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ';
                if (eventIdInput) eventIdInput.value = eventData.id;

                const titleField = eventForm.querySelector('[name="Title"]');
                const startTimeField = eventForm.querySelector('[name="StartTime"]');
                const endTimeField = eventForm.querySelector('[name="EndTime"]');
                const descriptionField = eventForm.querySelector('[name="Description"]');
                const eventTypeField = eventForm.querySelector('[name="event_type"]');
                const colourField = eventForm.querySelector('[name="Colour"]');

                if (titleField) titleField.value = eventData.Title;
                if (startTimeField) startTimeField.value = eventData.StartTime.substring(0, 16);
                if (endTimeField) endTimeField.value = eventData.EndTime.substring(0, 16);
                if (descriptionField) descriptionField.value = eventData.Description;
                if (eventTypeField) eventTypeField.value = eventData.event_type;
                if (colourField) colourField.value = eventData.Colour;

                eventForm.action = `/edit_event/${eventData.id}/`;
                eventModal.style.display = 'block';

            } catch (error) {
                console.error("Error opening event modal for edit:", error);
                alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Ñ–æ—Ä–º—ã —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏—è.");
            }
        }
        
        if (eventModalCloseButton) {
            eventModalCloseButton.addEventListener('click', () => {
                if (eventModal) eventModal.style.display = 'none';
            });
        }

        // Resizer Functionality (Modified)
        const leftColumn = document.querySelector('.main-page-left-column');
        const centerColumn = document.querySelector('.main-page-center-column');
        const rightColumn = document.querySelector('.main-page-right-column');
        const resizerLeftCenter = document.getElementById('resizer-left-center');
        const resizerCenterRight = document.getElementById('resizer-center-right');

        function makeResizable(resizer, prevElement, nextElement) {
            let x = 0;
            let prevElementWidth = 0;
            let nextElementWidth = 0;

            const mouseDownHandler = function (e) {
                x = e.clientX;
                prevElementWidth = prevElement.getBoundingClientRect().width;
                
                if (resizer.id === 'resizer-center-right') {
                    nextElementWidth = nextElement.getBoundingClientRect().width;
                } else {
                    nextElementWidth = 0; 
                }
                
                resizer.classList.add('active');
                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
            };

            const mouseMoveHandler = function (e) {
                const dx = e.clientX - x;
                const newPrevWidth = prevElementWidth + dx;
                const prevMinWidth = parseInt(getComputedStyle(prevElement).minWidth);
                
                if (resizer.id === 'resizer-center-right') { 
                    const newNextWidth = nextElementWidth - dx;
                    const nextMinWidth = parseInt(getComputedStyle(nextElement).minWidth);
                    if (newPrevWidth >= prevMinWidth && newNextWidth >= nextMinWidth) {
                        prevElement.style.flexBasis = `${newPrevWidth}px`;
                        nextElement.style.flexBasis = `${newNextWidth}px`;
                    }
                } else { 
                    if (newPrevWidth >= prevMinWidth) {
                        prevElement.style.flexBasis = `${newPrevWidth}px`;
                    }
                }
            };

            const mouseUpHandler = function () {
                resizer.classList.remove('active');
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
            };

            if (resizer) {
                 resizer.addEventListener('mousedown', mouseDownHandler);
            }
        }

        if (leftColumn && centerColumn && resizerLeftCenter) {
            makeResizable(resizerLeftCenter, leftColumn, centerColumn);
        }
        if (centerColumn && rightColumn && resizerCenterRight) {
            makeResizable(resizerCenterRight, centerColumn, rightColumn);
        }

        const createEventGeneralButton = document.getElementById('createEventGeneralBtn');
        if (createEventGeneralButton) {
            createEventGeneralButton.addEventListener('click', () => {
                openEventModal(); // Open modal without pre-filling date
            });
        }
    });
  </script>
{% endblock %}
