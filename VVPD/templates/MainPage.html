{% extends 'base.html' %}
{% load static %}

{% block title %}Schedle | –ì–ª–∞–≤–Ω–∞—è{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/main_page_v2.css' %}">
<link rel="stylesheet" href="{% static 'css/profile_modal.css' %}">
{% endblock %}

{% block content %}
<div class="main-layout-container">

    <!-- Left Panel: Friends and Chats -->
    <aside class="left-panel">
        <div class="left-panel-tabs">
            <button class="tab-link active" onclick="openTab(event, 'friends-tab-content')">–î—Ä—É–∑—å—è</button>
            <button class="tab-link" onclick="openTab(event, 'chats-tab-content')">–ß–∞—Ç—ã</button>
        </div>

        <div id="friends-tab-content" class="tab-content" style="display: block;">
            <div class="panel-search-container">
                <input type="text" id="friendSearchInput" placeholder="üîç –ü–æ–∏—Å–∫ –≤ –¥—Ä—É–∑—å—è—Ö" class="panel-search-input">
            </div>
            <button class="action-button panel-button create-group-btn">
                <span class="icon-plus-mainpage">+</span> –°–æ–∑–¥–∞—Ç—å –≥—Ä—É–ø–ø—É
            </button>
            <a href="{% url 'friend_requests' %}" class="action-button panel-button friend-requests-btn">
                <span class="icon-users-mainpage">üë•</span> –ó–∞—è–≤–∫–∏ –≤ –¥—Ä—É–∑—å—è <span class="badge" id="friendRequestsCount"></span>
            </a>
            <div class="friend-list-container" id="friendListContainer">
                <p class="placeholder-text">–ó–∞–≥—Ä—É–∑–∫–∞ –¥—Ä—É–∑–µ–π...</p>
            </div>
        </div>

        <div id="chats-tab-content" class="tab-content">
            <div class="panel-search-container">
                <input type="text" id="chatSearchInput" placeholder="üîç –ü–æ–∏—Å–∫ –≤ —á–∞—Ç–∞—Ö" class="panel-search-input">
            </div>
            <div class="chat-list-container" id="chatListContainer">
                <p class="placeholder-text">–ó–∞–≥—Ä—É–∑–∫–∞ —á–∞—Ç–æ–≤...</p>
            </div>
        </div>
    </aside>

    <!-- Center Panel: Schedule Editing Tools (WAS Right Panel) -->
    <aside class="center-panel editing-panel">
        <h4>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ</h4>
        
        <div class="small-calendar-container">
            <div class="calendar-header-mainpage small-calendar-header">
                <div class="month-year-display">
                    <span id="currentSmallMonth">–ú–µ—Å—è—Ü</span> <span id="currentSmallYear">–ì–æ–¥</span>
                </div>
                <div class="calendar-nav-buttons">
                    <button id="prevSmallMonthBtn">&lt;</button>
                    <button id="nextSmallMonthBtn">&gt;</button>
                </div>
            </div>
            <table class="calendar-grid-mainpage small-calendar-grid">
                <thead><tr><th>–ü–ù</th><th>–í–¢</th><th>–°–†</th><th>–ß–¢</th><th>–ü–¢</th><th>–°–ë</th><th>–í–°</th></tr></thead>
                <tbody id="smallCalendarDaysBody"></tbody>
            </table>
        </div>

        <div class="event-filters-container">
            <h5>–§–∏–ª—å—Ç—Ä—ã:</h5>
            <div><input type="checkbox" id="filterPersonal" name="filterPersonal" checked> <label for="filterPersonal">–õ–∏—á–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è</label></div>
            <div><input type="checkbox" id="filterFriends" name="filterFriends" checked> <label for="filterFriends">–°–æ–±—ã—Ç–∏—è —Å –¥—Ä—É–∑—å—è–º–∏</label></div>
            <div><input type="checkbox" id="filterWork" name="filterWork" checked> <label for="filterWork">–†–∞–±–æ—á–∏–µ/—É—á–µ–±–Ω—ã–µ –¥–µ–ª–∞</label></div>
        </div>

        <div class="event-form-container">
            <h5 id="eventFormTitle">–°–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ</h5>
            <form method="POST" id="eventFormInline" action="{% url 'create_event' %}">
                {% csrf_token %}
                <input type="hidden" name="event_id" id="inline_event_id">
                <div class="form-field"><label for="id_Title">–ù–∞–∑–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è:</label>{{ event_form.Title }}</div>
                <div class="form-field"><label for="id_StartTime">–í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞:</label>{{ event_form.StartTime }}</div>
                <div class="form-field"><label for="id_EndTime">–í—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è:</label>{{ event_form.EndTime }}</div>
                <div class="form-field"><label for="id_Description">–û–ø–∏—Å–∞–Ω–∏–µ:</label>{{ event_form.Description }}</div>
                <div class="form-field"><label for="id_event_type">–¢–∏–ø —Å–æ–±—ã—Ç–∏—è:</label>{{ event_form.event_type }}</div>
                <div class="form-field"><label for="id_Colour">–¶–≤–µ—Ç (hex):</label>{{ event_form.Colour }}</div>
                <div class="form-actions"><button type="submit" class="action-button">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ</button></div>
            </form>
        </div>
    </aside>

    <!-- Right Panel: Timeline Calendar (WAS Center Panel) -->
    <div class="timeline-section">
        <div id="timelineHeader" class="timeline-header-row"></div>
        <main class="right-panel timeline-panel" id="timelineViewContainer">
            <p class="placeholder-text">–ö–∞–ª–µ–Ω–¥–∞—Ä—å-—Ç–∞–π–º–ª–∞–π–Ω –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è...</p>
        </main>
    </div>

</div>

<!-- Profile Modal (Preserved) -->
<div class="modal" id="profileModal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header"><h2 class="modal-title">–ü—Ä–æ—Ñ–∏–ª—å</h2><button class="close-button" id="profileModalCloseButton">&times;</button></div>
        <form method="POST" action="{% url 'edit_profile' %}" enctype="multipart/form-data" id="profileForm">
            {% csrf_token %}
            <div class="profile-view-main-info">
                {% if user_profile.profile_picture %}
                    <img src="{{ user_profile.profile_picture.url }}" alt="–§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è" class="profile-photo-display">
                {% else %}
                    <img src="{% static 'images/default_avatar.png' %}" alt="–§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è" class="profile-photo-display" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                    <div class="profile-photo-default-circle"></div>
                {% endif %}
                <div class="profile-text-info">
                    <p class="profile-name">{{ user.get_full_name|default:user.username }}</p>
                    <p class="profile-username">@{{ user.username }}</p>
                    <p class="profile-email">{{ user.email }}</p>
                </div>
                <a href="#" id="editProfileLink" class="edit-profile-link">‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å</a>
            </div>
            <div id="profileEditForm" style="display: none;">
                <h4>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é</h4>
                <div class="profile-edit-field"><label for="profile_pic_input">–§–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è:</label><input type="file" name="profile_picture" accept="image/*" id="profile_pic_input"></div>
                <div class="profile-edit-field"><label for="first_name_input">–ò–º—è:</label><input type="text" value="{{ user.first_name }}" name="first_name" id="first_name_input"></div>
                <div class="profile-edit-field"><label for="last_name_input">–§–∞–º–∏–ª–∏—è:</label><input type="text" value="{{ user.last_name }}" name="last_name" id="last_name_input"></div>
                <div class="profile-edit-field"><label for="email_input">Email:</label><input type="email" value="{{ user.email }}" name="email" id="email_input"></div>
            </div>
            <div class="profile-section-divider">–ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å</div>
            <div class="profile-settings-list">
                <div class="profile-field"><span>–ö—Ç–æ –≤–∏–¥–∏—Ç –ª–∏—á–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ</span><a href="#" class="profile-field-value" data-setting="privacy_schedule_visibility">{{ user_profile.get_privacy_schedule_visibility_display }}</a></div>
                <div class="profile-field"><span>–ö—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≥–ª–∞—à–∞—Ç—å –Ω–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è</span><a href="#" class="profile-field-value" data-setting="privacy_can_invite_to_event">{{ user_profile.get_privacy_can_invite_to_event_display }}</a></div>
                <div class="profile-field"><span>–ö—Ç–æ –º–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è</span><a href="#" class="profile-field-value" data-setting="privacy_can_send_message">{{ user_profile.get_privacy_can_send_message_display }}</a></div>
                <div class="profile-field"><span>–ö—Ç–æ –≤–∏–¥–∏—Ç —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è</span><a href="#" class="profile-field-value" data-setting="privacy_profile_photo_visibility">{{ user_profile.get_privacy_profile_photo_visibility_display }}</a></div>
            </div>
            <div id="privacyEditForm" style="display: none;">
                <h4>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏</h4>
                <div class="profile-edit-field"><label for="id_privacy_schedule_visibility">–ö—Ç–æ –≤–∏–¥–∏—Ç –ª–∏—á–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ:</label><select name="privacy_schedule_visibility" id="id_privacy_schedule_visibility">{% for value, text in user_profile.PRIVACY_CHOICES %}<option value="{{ value }}" {% if user_profile.privacy_schedule_visibility == value %}selected{% endif %}>{{ text }}</option>{% endfor %}</select></div>
                <div class="profile-edit-field"><label for="id_privacy_can_invite_to_event">–ö—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≥–ª–∞—à–∞—Ç—å –Ω–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è:</label><select name="privacy_can_invite_to_event" id="id_privacy_can_invite_to_event">{% for value, text in user_profile.PRIVACY_CHOICES %}{% if value != 'only_me' %}<option value="{{ value }}" {% if user_profile.privacy_can_invite_to_event == value %}selected{% endif %}>{{ text }}</option>{% endif %}{% endfor %}</select></div>
                <div class="profile-edit-field"><label for="id_privacy_can_send_message">–ö—Ç–æ –º–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è:</label><select name="privacy_can_send_message" id="id_privacy_can_send_message">{% for value, text in user_profile.PRIVACY_CHOICES %}{% if value != 'only_me' %}<option value="{{ value }}" {% if user_profile.privacy_can_send_message == value %}selected{% endif %}>{{ text }}</option>{% endif %}{% endfor %}</select></div>
                <div class="profile-edit-field"><label for="id_privacy_profile_photo_visibility">–ö—Ç–æ –≤–∏–¥–∏—Ç —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è:</label><select name="privacy_profile_photo_visibility" id="id_privacy_profile_photo_visibility">{% for value, text in user_profile.PRIVACY_CHOICES %}<option value="{{ value }}" {% if user_profile.privacy_profile_photo_visibility == value %}selected{% endif %}>{{ text }}</option>{% endfor %}</select></div>
            </div>
            <div class="profile-section-divider">–û—Å—Ç–∞–ª—å–Ω–æ–µ</div>
            <div class="profile-settings-list"><div class="profile-field"><span>–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</span><a href="#" class="profile-field-value" data-setting="interface_language">{{ user_profile.interface_language }}</a></div></div>
            <div id="languageEditForm" style="display:none;">
              <h4>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —è–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</h4>
               <div class="profile-edit-field"><label for="id_interface_language">–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞:</label><select name="interface_language" id="id_interface_language"><option value="–†—É—Å—Å–∫–∏–π" {% if user_profile.interface_language == "–†—É—Å—Å–∫–∏–π" %}selected{% endif %}>–†—É—Å—Å–∫–∏–π</option><option value="English" {% if user_profile.interface_language == "English" %}selected{% endif %}>English</option></select></div>
            </div>
            <div class="profile-actions"><button type="submit" id="saveProfileButton" class="action-button" style="display:none;">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è</button><a href="{% url 'logout' %}" class="profile-action">–í—ã–π—Ç–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞</a><a href="#" class="profile-action danger" id="deleteAccountLink">–£–¥–∞–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç</a></div>
        </form>
    </div>
</div>

<!-- Event Create/Edit Modal -->
<div class="modal" id="eventModal" style="display: none;">
    <div class="modal-content event-modal-content">
        <div class="modal-header">
            <h2 class="modal-title" id="eventModalTitle">–°–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ</h2>
            <button class="close-button" id="eventModalCloseButton">&times;</button>
        </div>
        <form method="POST" id="eventModalForm" action="{% url 'create_event' %}">
            {% csrf_token %}
            <input type="hidden" name="event_id" id="modal_event_id">
            <div class="form-field">
                <label for="modal_id_Title">–ù–∞–∑–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è:</label>
                {{ event_form.Title }} <!-- Assuming event_form is available in context -->
            </div>
            <div class="form-field">
                <label for="modal_id_StartTime">–í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞:</label>
                {{ event_form.StartTime }}
            </div>
            <div class="form-field">
                <label for="modal_id_EndTime">–í—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è:</label>
                {{ event_form.EndTime }}
            </div>
            <div class="form-field">
                <label for="modal_id_Description">–û–ø–∏—Å–∞–Ω–∏–µ:</label>
                {{ event_form.Description }}
            </div>
            <div class="form-field">
                <label for="modal_id_event_type">–¢–∏–ø —Å–æ–±—ã—Ç–∏—è:</label>
                {{ event_form.event_type }}
            </div>
            <div class="form-field">
                <label for="modal_id_Colour">–¶–≤–µ—Ç (hex):</label>
                {{ event_form.Colour }}
            </div>
            <div class="form-actions modal-form-actions">
                <button type="submit" class="action-button" id="saveEventModalButton">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>,
                <button type="button" class="action-button-secondary" id="cancelEventModalButton">–û—Ç–º–µ–Ω–∞</button>
                <button type="button" class="action-button-danger" id="deleteEventModalButton" style="display:none;">–£–¥–∞–ª–∏—Ç—å</button>
            </div>
        </form>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    // Constants & Global Variables
    const defaultAvatarUrl = "{% static 'images/default_avatar.png' %}";
    const monthNames = ["–Ø–Ω–≤–∞—Ä—å", "–§–µ–≤—Ä–∞–ª—å", "–ú–∞—Ä—Ç", "–ê–ø—Ä–µ–ª—å", "–ú–∞–π", "–ò—é–Ω—å", "–ò—é–ª—å", "–ê–≤–≥—É—Å—Ç", "–°–µ–Ω—Ç—è–±—Ä—å", "–û–∫—Ç—è–±—Ä—å", "–ù–æ—è–±—Ä—å", "–î–µ–∫–∞–±—Ä—å"];
    const dayShortNames = ["–≤—Å", "–ø–Ω", "–≤—Ç", "—Å—Ä", "—á—Ç", "–ø—Ç", "—Å–±"];
    const EVENT_VERTICAL_DAY_HEIGHT_PX = 250; // REDUCED from 480
    const KRASNOYARSK_TIMEZONE = 'Asia/Krasnoyarsk';

    let currentSmallCalendarDate = new Date();
    let selectedStartDate = null;
    let selectedEndDate = null;

    // Helper function to get YYYY-MM-DD string in Krasnoyarsk Timezone
    function getKrasnoyarskDateString(dateObj) {
        return new Intl.DateTimeFormat('sv-SE', { timeZone: KRASNOYARSK_TIMEZONE }).format(dateObj);
    }

    // Helper function to convert UTC ISO string to YYYY-MM-DDTHH:MM for KRT display in input
    function convertUTCToKRT_YYYYMMDDTHHMM(utcIsoString) {
        if (!utcIsoString) return '';
        const date = new Date(utcIsoString); // Parses as UTC

        // Get KRT parts using Intl.DateTimeFormat, ensuring locale doesn't break YYYY-MM-DD or HH:MM
        const krtYear = new Intl.DateTimeFormat('en', { year: 'numeric', timeZone: KRASNOYARSK_TIMEZONE }).format(date);
        const krtMonth = new Intl.DateTimeFormat('en', { month: '2-digit', timeZone: KRASNOYARSK_TIMEZONE }).format(date);
        const krtDay = new Intl.DateTimeFormat('en', { day: '2-digit', timeZone: KRASNOYARSK_TIMEZONE }).format(date);
        // For hour, use a locale that reliably gives 24-hour format, like 'en-GB'
        let krtHour = new Intl.DateTimeFormat('en-GB', { hour: '2-digit', hour12: false, timeZone: KRASNOYARSK_TIMEZONE }).format(date);
        const krtMinute = new Intl.DateTimeFormat('en-GB', { minute: '2-digit', timeZone: KRASNOYARSK_TIMEZONE }).format(date);

        // Intl.DateTimeFormat might return '24' for hour at midnight, input type datetime-local expects '00'
        if (krtHour === '24') {
            krtHour = '00';
        }
        
        return `${krtYear}-${krtMonth}-${krtDay}T${String(krtHour).padStart(2,'0')}:${String(krtMinute).padStart(2,'0')}`;
    }

    // DOM Elements
    const timelineViewContainer = document.getElementById('timelineViewContainer'); // Now right panel
    const eventFormInline = document.getElementById('eventFormInline'); // Now in center panel
    const eventFormTitle = document.getElementById('eventFormTitle');
    const inlineEventIdInput = document.getElementById('inline_event_id');
    
    const currentSmallMonthEl = document.getElementById('currentSmallMonth');
    const currentSmallYearEl = document.getElementById('currentSmallYear');
    const smallCalendarDaysBodyEl = document.getElementById('smallCalendarDaysBody');
    const prevSmallMonthBtn = document.getElementById('prevSmallMonthBtn');
    const nextSmallMonthBtn = document.getElementById('nextSmallMonthBtn');

    const friendSearchInput = document.getElementById('friendSearchInput');
    const chatSearchInput = document.getElementById('chatSearchInput');
    const friendListContainer = document.getElementById('friendListContainer');
    const chatListContainer = document.getElementById('chatListContainer');

    // Profile Modal Elements
    const profileButton = document.getElementById('headerProfileIcon'); // Assumes this ID is on your header profile icon
    const profileModal = document.getElementById('profileModal');
    const profileModalCloseButton = document.getElementById('profileModalCloseButton');
    const editProfileLink = document.getElementById('editProfileLink');
    const profileForm = document.getElementById('profileForm'); // Added ID to form
    const profileViewMainInfo = profileModal.querySelector('.profile-view-main-info');
    const profileEditForm = document.getElementById('profileEditForm');
    const privacyEditForm = document.getElementById('privacyEditForm');
    const languageEditForm = document.getElementById('languageEditForm');
    const saveProfileButton = document.getElementById('saveProfileButton');
    const deleteAccountLink = document.getElementById('deleteAccountLink');

    // Event Modal Elements (NEW)
    const eventModal = document.getElementById('eventModal');
    const eventModalTitle = document.getElementById('eventModalTitle');
    const eventModalForm = document.getElementById('eventModalForm');
    const modalEventIdInput = document.getElementById('modal_event_id');
    const eventModalCloseButton = document.getElementById('eventModalCloseButton');
    const saveEventModalButton = document.getElementById('saveEventModalButton');
    const cancelEventModalButton = document.getElementById('cancelEventModalButton');
    const deleteEventModalButton = document.getElementById('deleteEventModalButton');

    // Tab switching logic for left panel
    window.openTab = function(evt, tabName) {
        let i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tab-content");
        for (i = 0; i < tabcontent.length; i++) { tabcontent[i].style.display = "none"; }
        tablinks = document.getElementsByClassName("tab-link");
        for (i = 0; i < tablinks.length; i++) { tablinks[i].className = tablinks[i].className.replace(" active", ""); }
        document.getElementById(tabName).style.display = "flex";
        evt.currentTarget.className += " active";
        if (tabName === 'friends-tab-content') { loadFriends(); }
        if (tabName === 'chats-tab-content') { loadChats(); }
    }

    // --- Profile Modal Logic ---
    if (profileButton) {
        profileButton.addEventListener('click', () => {
            profileModal.style.display = 'flex';
            profileViewMainInfo.style.display = '';
            profileEditForm.style.display = 'none';
            privacyEditForm.style.display = 'none';
            languageEditForm.style.display = 'none';
            saveProfileButton.style.display = 'none';
            editProfileLink.textContent = '‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å';
            profileModal.querySelectorAll('.profile-settings-list').forEach(list => list.style.display = '');
        });
    }
    if (profileModalCloseButton) {
        profileModalCloseButton.addEventListener('click', () => profileModal.style.display = 'none');
    }
    if (editProfileLink) {
        editProfileLink.addEventListener('click', (e) => {
            e.preventDefault();
            const isEditing = profileEditForm.style.display !== 'none';
            profileViewMainInfo.style.display = isEditing ? '' : 'none';
            profileEditForm.style.display = isEditing ? 'none' : 'block';
            privacyEditForm.style.display = isEditing ? 'none' : 'block';
            languageEditForm.style.display = isEditing ? 'none' : 'block';
            saveProfileButton.style.display = isEditing ? 'none' : 'block';
            editProfileLink.textContent = isEditing ? '‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å' : '‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞';
            profileModal.querySelectorAll('.profile-settings-list').forEach(list => list.style.display = isEditing ? '' : 'none');
        });
    }
    if (deleteAccountLink) {
        deleteAccountLink.addEventListener('click', (e) => {
            e.preventDefault();
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —Å–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.')) {
                // Implement account deletion logic, likely a POST request to a specific URL
                alert('–ê–∫–∫–∞—É–Ω—Ç —É–¥–∞–ª–µ–Ω (–¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è).'); // Placeholder
                window.location.href = '/'; // Redirect to home or login
            }
        });
    }
    // Add form submission logic if needed (e.g. AJAX for profileForm)


    // --- Small Calendar Functionality ---
    function renderSmallCalendar() {
        const localYear = currentSmallCalendarDate.getFullYear();
        const localMonth = currentSmallCalendarDate.getMonth();
        if (currentSmallMonthEl) currentSmallMonthEl.textContent = monthNames[localMonth];
        if (currentSmallYearEl) currentSmallYearEl.textContent = localYear;

        const timelineHeaderMonthTitle = document.querySelector('#timelineHeader .timeline-month-title');
        if (timelineHeaderMonthTitle) {
            timelineHeaderMonthTitle.textContent = monthNames[localMonth];
        }

        if (!smallCalendarDaysBodyEl) return;
        smallCalendarDaysBodyEl.innerHTML = '';

        // Get KRT representation of the 1st of the current localMonth
        const firstOfDisplayedMonthKRT = new Date(Date.UTC(localYear, localMonth, 1, 0, 0, 0 - (7*60*60*1000) )); // Rough UTC for KRT midnight
        const krtYearForLogic = parseInt(new Intl.DateTimeFormat('en', { year: 'numeric', timeZone: KRASNOYARSK_TIMEZONE }).format(firstOfDisplayedMonthKRT));
        const krtMonthForLogic = parseInt(new Intl.DateTimeFormat('en', { month: 'numeric', timeZone: KRASNOYARSK_TIMEZONE }).format(firstOfDisplayedMonthKRT)) -1; // 0-indexed

        const firstDayOfMonthObject = new Date(krtYearForLogic, krtMonthForLogic, 1);
        const firstDayOfMonthWeekday = firstDayOfMonthObject.toLocaleDateString('en-US', { weekday: 'long', timeZone: KRASNOYARSK_TIMEZONE });
        // Convert weekday name to number (Mon=0...Sun=6) aligning with typical calendar grids
        const dayNameToIndex = {'Monday':0, 'Tuesday':1, 'Wednesday':2, 'Thursday':3, 'Friday':4, 'Saturday':5, 'Sunday':6};
        let startingDay = dayNameToIndex[firstDayOfMonthWeekday] !== undefined ? dayNameToIndex[firstDayOfMonthWeekday] : (new Date(localYear, localMonth, 1).getDay() + 6) % 7; // Fallback

        const daysInMonth = new Date(krtYearForLogic, krtMonthForLogic + 1, 0).getDate();
        const daysInPrevMonth = new Date(krtYearForLogic, krtMonthForLogic, 0).getDate();

        let dateCounter = 1;
        let nextMonthDateCounter = 1;

        for (let i = 0; i < 6; i++) { // Max 6 weeks
            const row = document.createElement('tr');
            for (let j = 0; j < 7; j++) { // 7 days a week
                const cell = document.createElement('td');
                const dateNumberDiv = document.createElement('div');
                dateNumberDiv.classList.add('date-number');
                
                let cellRepresentedDateObj; // JS Date object for the current cell
                let cellDateKRTString;    // YYYY-MM-DD in KRT

                if (i === 0 && j < startingDay) { // Previous month
                    const prevMonthDay = daysInPrevMonth - startingDay + j + 1;
                    dateNumberDiv.textContent = prevMonthDay;
                    cell.classList.add('other-month');
                    cellRepresentedDateObj = new Date(krtYearForLogic, krtMonthForLogic - 1, prevMonthDay);
                } else if (dateCounter > daysInMonth) { // Next month
                    dateNumberDiv.textContent = nextMonthDateCounter;
                    cell.classList.add('other-month');
                    cellRepresentedDateObj = new Date(krtYearForLogic, krtMonthForLogic + 1, nextMonthDateCounter);
                    nextMonthDateCounter++;
                } else { // Current month
                    dateNumberDiv.textContent = dateCounter;
                    cell.classList.add('current-month');
                    cell.classList.add('calendar-day-mainpage'); 
                    cellRepresentedDateObj = new Date(krtYearForLogic, krtMonthForLogic, dateCounter);
                    
                    const todayKRTStr = getKrasnoyarskDateString(new Date());
                    if (getKrasnoyarskDateString(cellRepresentedDateObj) === todayKRTStr) {
                        cell.classList.add('today-mainpage');
                    }
                    dateCounter++;
                }
                cellDateKRTString = getKrasnoyarskDateString(cellRepresentedDateObj);
                cell.dataset.date = cellDateKRTString; // Store KRT date string
                cell.appendChild(dateNumberDiv);

                // Apply selection styles based on KRT strings
                if (selectedStartDate && selectedEndDate) {
                    if (cellDateKRTString >= selectedStartDate && cellDateKRTString <= selectedEndDate) {
                        cell.classList.add('selected-range');
                    }
                }
                if (cellDateKRTString === selectedStartDate) cell.classList.add('selected-start');
                if (cellDateKRTString === selectedEndDate) cell.classList.add('selected-end');
                
                row.appendChild(cell);
            }
            smallCalendarDaysBodyEl.appendChild(row);
            if (dateCounter > daysInMonth && i >= Math.floor((startingDay + daysInMonth -1) / 7) ) break; 
        }
    }

    if (prevSmallMonthBtn) prevSmallMonthBtn.addEventListener('click', () => { 
        currentSmallCalendarDate.setMonth(currentSmallCalendarDate.getMonth() - 1); 
        selectedStartDate = null; // Clear selection from previous month
        selectedEndDate = null;
        renderSmallCalendar(); 
        // Update timeline to show the new month
        const year = currentSmallCalendarDate.getFullYear();
        const month = currentSmallCalendarDate.getMonth();
        const firstDayOfMonth = new Date(year, month, 1);
        const lastDayOfMonth = new Date(year, month + 1, 0);
        generateTimelineView(firstDayOfMonth, lastDayOfMonth);
    });

    if (nextSmallMonthBtn) nextSmallMonthBtn.addEventListener('click', () => { 
        currentSmallCalendarDate.setMonth(currentSmallCalendarDate.getMonth() + 1); 
        selectedStartDate = null; // Clear selection from previous month
        selectedEndDate = null;
        renderSmallCalendar(); 
        // Update timeline to show the new month
        const year = currentSmallCalendarDate.getFullYear();
        const month = currentSmallCalendarDate.getMonth();
        const firstDayOfMonth = new Date(year, month, 1);
        const lastDayOfMonth = new Date(year, month + 1, 0);
        generateTimelineView(firstDayOfMonth, lastDayOfMonth);
    });
    
    if (smallCalendarDaysBodyEl) {
        smallCalendarDaysBodyEl.addEventListener('click', (e) => {
            const targetCell = e.target.closest('td');
            if (!targetCell || !targetCell.dataset.date) return;

            const clickedDateStr = targetCell.dataset.date; // This is KRT YYYY-MM-DD

            if (!selectedStartDate || (selectedStartDate && selectedEndDate)) {
                selectedStartDate = clickedDateStr; // Store KRT string
                selectedEndDate = null; 
            } else if (clickedDateStr < selectedStartDate) { 
                selectedEndDate = selectedStartDate;
                selectedStartDate = clickedDateStr; // Store KRT string
            } else {
                selectedEndDate = clickedDateStr; // Store KRT string
            }
            
            renderSmallCalendar(); 
            if (timelineViewContainer) {
                 // Convert KRT date strings to Date objects representing KRT day boundaries
                 // The Date objects will represent UTC moments equivalent to 00:00 KRT and 23:59 KRT
                 const startForTimeline = new Date(selectedStartDate + "T00:00:00+07:00");
                 const endForTimeline = selectedEndDate ? 
                                      new Date(selectedEndDate + "T23:59:59.999+07:00") : 
                                      new Date(selectedStartDate + "T23:59:59.999+07:00");
                 console.log('Timeline RENDER: generateTimelineView called with KRT-derived Date objects. Selected KRT strings:', selectedStartDate, selectedEndDate);
                 generateTimelineView(startForTimeline, endForTimeline);
            }
        });
    }

    // --- Timeline View Generation (Targets right panel) ---
    async function generateTimelineView(startDate, endDate) {
        if (!timelineViewContainer) {
            console.error("timelineViewContainer is null or undefined!");
            return;
        }
        console.log('generateTimelineView received raw startDate:', startDate, 'endDate:', endDate);

        if (!(startDate instanceof Date) || isNaN(startDate.getTime())) {
            console.error("ERROR: startDate is not a valid Date object in generateTimelineView.", startDate);
            timelineViewContainer.innerHTML = '<p class="placeholder-text">–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω–∞—è –Ω–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞.</p>';
            return;
        }
        if (!(endDate instanceof Date) || isNaN(endDate.getTime())) {
            console.error("ERROR: endDate is not a valid Date object in generateTimelineView.", endDate);
            timelineViewContainer.innerHTML = '<p class="placeholder-text">–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–Ω–µ—á–Ω–∞—è –¥–∞—Ç–∞.</p>';
            return;
        }

        timelineViewContainer.innerHTML = '<p class="placeholder-text">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–Ω–µ–π...</p>';

        let currentDate = new Date(startDate); // Use a copy to avoid modifying the passed-in startDate
        currentDate.setHours(0, 0, 0, 0);     // Normalize to the beginning of the day

        let tempEndDate = new Date(endDate);   // Use a copy
        tempEndDate.setHours(23, 59, 59, 999); // Normalize to the end of the day for inclusive comparison

        console.log('Normalized loop range: currentDate:', currentDate.toISOString(), 'tempEndDate:', tempEndDate.toISOString());

        if (currentDate > tempEndDate) {
            console.warn('Warning: currentDate is after tempEndDate. No days will be rendered.', currentDate, tempEndDate);
            timelineViewContainer.innerHTML = '<p class="placeholder-text">–í—ã–±—Ä–∞–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω (–Ω–∞—á–∞–ª–æ –ø–æ—Å–ª–µ –∫–æ–Ω—Ü–∞).</p>';
            return;
        }

        const fragment = document.createDocumentFragment();
        let dayRendered = false;

        while (currentDate <= tempEndDate) {
            dayRendered = true;
            console.log('Rendering day in loop:', currentDate.toISOString().split('T')[0]);
            
            const dayDateForAPI = getKrasnoyarskDateString(currentDate); // KRT date string

            const dayEntry = document.createElement('div');
            dayEntry.classList.add('timeline-day-entry-vertical');
            dayEntry.dataset.date = dayDateForAPI; // Store KRT date string

            const dayLabelDiv = document.createElement('div');
            dayLabelDiv.classList.add('day-label-main-vertical');
            
            const dateNumberSpan = document.createElement('span');
            dateNumberSpan.classList.add('day-label-date-number');
            dateNumberSpan.textContent = currentDate.getDate();

            const dayNameSpan = document.createElement('span');
            dayNameSpan.classList.add('day-label-day-name');
            dayNameSpan.textContent = dayShortNames[currentDate.getDay()];

            dayLabelDiv.appendChild(dateNumberSpan);
            dayLabelDiv.appendChild(dayNameSpan);

            dayLabelDiv.addEventListener('click', () => {
                if (eventModalTitle) eventModalTitle.textContent = '–°–æ–∑–¥–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ';
                if (eventModalForm) {
                    eventModalForm.reset(); 
                    eventModalForm.action = "{% url 'create_event' %}";
                    const clickedDate = dayEntry.dataset.date;
                    const startTimeField = eventModalForm.querySelector('[name="StartTime"]');
                    const endTimeField = eventModalForm.querySelector('[name="EndTime"]');
                    if (startTimeField) {
                        startTimeField.value = clickedDate + 'T09:00'; 
                    }
                    if (endTimeField) {
                        endTimeField.value = clickedDate + 'T10:00';
                    }
                    const colourFieldModal = eventModalForm.querySelector('[name="Colour"]');
                    if (colourFieldModal) colourFieldModal.value = '#007bff';
                }
                if (modalEventIdInput) modalEventIdInput.value = ''; 
                if (deleteEventModalButton) deleteEventModalButton.style.display = 'none';
                openEventModal();
            });

            const dayBodyVertical = document.createElement('div');
            dayBodyVertical.classList.add('timeline-day-body-vertical');

            const eventArea = document.createElement('div');
            eventArea.classList.add('event-area-vertical');

            dayBodyVertical.appendChild(eventArea);

            dayEntry.appendChild(dayLabelDiv);
            dayEntry.appendChild(dayBodyVertical);
            
            fragment.appendChild(dayEntry);

            // Pass only eventArea to fetchAndDisplayEventsForVerticalDay
            // RENAME fetchAndDisplayEventsForVerticalDay to fetchAndDisplayEventsForDayRow
            // Pass krtDateStrForAPI (dayDateForAPI) to fetchAndDisplayEventsForDayRow
            await fetchAndDisplayEventsForDayRow(new Date(currentDate), eventArea, dayDateForAPI); 
            
            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        if (dayRendered) {
            console.log('Clearing timelineViewContainer and appending new fragment.');
            console.log('Fragment childElementCount before append:', fragment.childElementCount); // DEBUG LINE
            timelineViewContainer.innerHTML = ''; 
            timelineViewContainer.appendChild(fragment);
            console.log('timelineViewContainer innerHTML after append:', timelineViewContainer.innerHTML); // DEBUG LINE
        } else {
            console.log('No days were rendered. currentDate might have been > tempEndDate initially or loop condition failed.');
            timelineViewContainer.innerHTML = '<p class="placeholder-text">–ù–µ—Ç —Å–æ–±—ã—Ç–∏–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –¥–∞–Ω–Ω–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ.</p>'; // More specific message
        }
    }

    // RENAMED from fetchAndDisplayEventsForVerticalDay
    async function fetchAndDisplayEventsForDayRow(dateObj, eventAreaElement, krtDateStrForAPI) {
        // const dateStr = dateObj.toISOString().split('T')[0]; // OLD: This is YYYY-MM-DD in UTC
        
        eventAreaElement.innerHTML = ''; 
        try {
            // API call uses krtDateStrForAPI
            const response = await fetch(`/api/events_for_day/${krtDateStrForAPI}/`); 
            if (!response.ok) {
                console.error(`Error fetching events for ${krtDateStrForAPI}: ${response.status}`);
                eventAreaElement.innerHTML = '<span class="timeline-event-placeholder">–û—à–∏–±–∫–∞</span>';
                return;
            }
            const rawEvents = await response.json();
            const events = rawEvents.filter(e => e && typeof e === 'object' && e.StartTime && e.EndTime && e.Title);

            if (events.length === 0) {
                const placeholder = document.createElement('span');
                placeholder.classList.add('timeline-event-placeholder');
                placeholder.textContent = '–Ω–µ—Ç —Å–æ–±—ã—Ç–∏–π –Ω–∞ –¥–µ–Ω—å';
                eventAreaElement.appendChild(placeholder);
                return;
            }
            
            // Define view window based on 6 AM KRT for krtDateStrForAPI, converted to true UTC
            const viewWindowStart_KRT_asText = krtDateStrForAPI + "T06:00:00";
            // Use +07:00 for Krasnoyarsk time (UTC+7)
            const viewWindowStartForDay_TrueUTC = new Date(Date.parse(viewWindowStart_KRT_asText + "+07:00"));
            const viewWindowEndForDay_TrueUTC = new Date(viewWindowStartForDay_TrueUTC.getTime() + 24 * 60 * 60 * 1000);

            const TOTAL_MINUTES_IN_TIMELINE_VIEW = 24 * 60;

            let processedEvents = events.map(event => {
                // Ensure StartTime and EndTime strings are parsed as UTC if they are naive
                const startTimeStr = event.StartTime;
                const endTimeStr = event.EndTime;

                const ensureUTC = (dateStr) => {
                    if (!dateStr) return null;
                    // Check if it already has timezone info (Z or +/-HH:MM or +/-HHMM)
                    if (dateStr.endsWith('Z') || /[+\-]\d{2}:?\d{2}$/.test(dateStr)) {
                        return new Date(dateStr);
                    }
                    // If naive (e.g., YYYY-MM-DDTHH:MM:SS), append 'Z' to parse as UTC
                    return new Date(dateStr + 'Z');
                };

                let actualStart = ensureUTC(startTimeStr);
                let actualEnd = ensureUTC(endTimeStr);

                if (!actualStart || !actualEnd) return null; // Invalid date string

                // Clip event start and end times to the KRT-based window (viewWindowStartForDay_TrueUTC)
                let clippedStart_UTC = actualStart.getTime() < viewWindowStartForDay_TrueUTC.getTime() ? viewWindowStartForDay_TrueUTC : actualStart;
                let clippedEnd_UTC = actualEnd.getTime() > viewWindowEndForDay_TrueUTC.getTime() ? viewWindowEndForDay_TrueUTC : actualEnd;

                if (clippedStart_UTC.getTime() >= clippedEnd_UTC.getTime()) return null;

                // Calculate startMinutesInWindow relative to viewWindowStartForDay_TrueUTC
                let startMinutesInWindow = (clippedStart_UTC.getTime() - viewWindowStartForDay_TrueUTC.getTime()) / (60 * 1000);
                startMinutesInWindow = Math.max(0, startMinutesInWindow); // Ensure non-negative
                
                let durationInWindowMinutes = (clippedEnd_UTC.getTime() - clippedStart_UTC.getTime()) / (1000 * 60);
                durationInWindowMinutes = Math.max(15, durationInWindowMinutes); 

                if (startMinutesInWindow + durationInWindowMinutes > TOTAL_MINUTES_IN_TIMELINE_VIEW) {
                    durationInWindowMinutes = TOTAL_MINUTES_IN_TIMELINE_VIEW - startMinutesInWindow;
                }
                if (durationInWindowMinutes <= 0) return null;

                return {
                    ...event,
                    id: event.id,
                    title: event.Title,
                    color: event.Colour,
                    originalStartTime: actualStart, 
                    originalEndTime: actualEnd,
                    startMinutes: startMinutesInWindow,
                    durationMinutes: durationInWindowMinutes,
                    leftPercent: (startMinutesInWindow / TOTAL_MINUTES_IN_TIMELINE_VIEW) * 100,
                    widthPercent: (durationInWindowMinutes / TOTAL_MINUTES_IN_TIMELINE_VIEW) * 100, // Removed Math.max and large minimum
                };
            }).filter(e => e !== null);

            processedEvents.sort((a, b) => a.startMinutes - b.startMinutes || (b.startMinutes + b.durationMinutes) - (a.startMinutes + a.durationMinutes));

            const eventHeightPx = 60; 
            const eventGapPx = 6;   
            
            processedEvents.forEach(event => event.lane = 0);

            for (let i = 0; i < processedEvents.length; i++) {
                const currentEvent = processedEvents[i];
                let assignedLane = 0;
                let conflictResolved = false;
                while(!conflictResolved) {
                    let inConflictWithOtherInLane = false;
                    for (let j = 0; j < i; j++) { 
                        const placedEvent = processedEvents[j];
                        if (placedEvent.lane === assignedLane) { 
                            const currentEventEndM = currentEvent.startMinutes + currentEvent.durationMinutes;
                            const placedEventEndM = placedEvent.startMinutes + placedEvent.durationMinutes;
                            if (currentEvent.startMinutes < placedEventEndM && currentEventEndM > placedEvent.startMinutes) {
                                inConflictWithOtherInLane = true;
                                break; 
                            }
                        }
                    }
                    if (!inConflictWithOtherInLane) {
                        currentEvent.lane = assignedLane;
                        conflictResolved = true;
                    } else {
                        assignedLane++; 
                    }
                }
            }
            
            let maxLanesUsed = 0;
            processedEvents.forEach(e => maxLanesUsed = Math.max(maxLanesUsed, e.lane + 1));
            eventAreaElement.style.minHeight = `${maxLanesUsed * (eventHeightPx + eventGapPx) + eventGapPx}px`;

            processedEvents.forEach(event => {
                const eventItem = document.createElement('div');
                eventItem.classList.add('timeline-event-item'); 
                eventItem.dataset.eventId = event.id;
                eventItem.style.backgroundColor = event.color || '#007bff';
                
                eventItem.style.position = 'absolute';
                eventItem.style.left = `${event.leftPercent}%`;
                const adjustedWidth = event.widthPercent >= 99 ? event.widthPercent : event.widthPercent - 0.2;
                eventItem.style.width = `${adjustedWidth}%`; 
                
                eventItem.style.top = `${event.lane * (eventHeightPx + eventGapPx) + eventGapPx}px`;
                eventItem.style.height = `${eventHeightPx}px`;

                // Display time and tooltip in Krasnoyarsk Time
                const krtDisplayOptions = { timeZone: KRASNOYARSK_TIMEZONE, hour: '2-digit', minute:'2-digit' };
                const krtTooltipOptions = { timeZone: KRASNOYARSK_TIMEZONE, year: 'numeric', month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit' };

                eventItem.innerHTML = `
                    <div class="timeline-event-time-start">${event.originalStartTime.toLocaleTimeString('ru-RU', krtDisplayOptions)}</div>
                    <strong class="timeline-event-title">${event.title}</strong>`;
                
                const startKRTStr = event.originalStartTime.toLocaleString('ru-RU', krtTooltipOptions);
                const endKRTStr = event.originalEndTime.toLocaleString('ru-RU', krtTooltipOptions);
                eventItem.setAttribute('title', `${event.title} (${startKRTStr} - ${endKRTStr})`);
                
                eventItem.addEventListener('click', () => {
                    openModalForEdit(event.id);
                });
                eventAreaElement.appendChild(eventItem);
            });

        } catch (error) {
            console.error(`Failed to fetch or parse events for ${krtDateStrForAPI}:`, error);
            eventAreaElement.innerHTML = '<span class="timeline-event-placeholder">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–±—ã—Ç–∏–π</span>';
        }
    }

    // --- Event Form (Inline) Functionality (Targets center panel) ---
    // Consider hiding or removing this section now that we have a modal
    // For now, I will hide it via CSS and comment out its JS logic initiation if any.
    const inlineFormContainer = document.querySelector('.event-form-container');
    if (inlineFormContainer) {
        inlineFormContainer.style.display = 'none'; // Hide it now
    }
    // function updateEventFormForRange(startDateStr, endDateStr) { ... } // OLD
    // async function openEventFormForEdit(eventId, displayedStartTimeStr, displayedEndTimeStr) { ... } // OLD
    // if (eventFormInline) { eventFormInline.addEventListener('submit', ... ); } // OLD

    // --- NEW: Modal Event Form Functions ---
    async function openModalForEdit(eventId) {
        if (!eventModalForm) return;
        try {
            const response = await fetch(`/api/event_detail/${eventId}/`);
            if (!response.ok) throw new Error('Failed to fetch event details for modal.');
            const eventData = await response.json();

            if (eventModalTitle) eventModalTitle.textContent = '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ';
            if (modalEventIdInput) modalEventIdInput.value = eventData.id;
            eventModalForm.action = `/edit_event/${eventData.id}/`;

            // Populate form fields in modal
            eventModalForm.querySelector('[name="Title"]').value = eventData.Title || '';
            eventModalForm.querySelector('[name="StartTime"]').value = convertUTCToKRT_YYYYMMDDTHHMM(eventData.StartTime);
            eventModalForm.querySelector('[name="EndTime"]').value = convertUTCToKRT_YYYYMMDDTHHMM(eventData.EndTime);
            eventModalForm.querySelector('[name="Description"]').value = eventData.Description || '';
            eventModalForm.querySelector('[name="event_type"]').value = eventData.event_type || ''; // Ensure a default if not present
            
            let colorVal = eventData.Colour;
            if (!colorVal || typeof colorVal !== 'string' || !colorVal.match(/^#[0-9a-fA-F]{6}$/)) {
                colorVal = '#007bff'; 
            }
            eventModalForm.querySelector('[name="Colour"]').value = colorVal;

            if (deleteEventModalButton) deleteEventModalButton.style.display = 'inline-block'; // Show delete button for existing events
            openEventModal();
        } catch (error) {
            console.error('Error opening event for modal edit:', error);
            alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.');
        }
    }

    if (eventModalForm) {
        eventModalForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            const formData = new FormData(eventModalForm);
            const url = eventModalForm.action;
            const method = 'POST';

            try {
                const response = await fetch(url, { method, body: formData, headers: {'X-CSRFToken': formData.get('csrfmiddlewaretoken')} });
                // Check if response is okay AND if it's JSON before trying to parse
                if (response.ok) {
                    const contentType = response.headers.get("content-type");
                    if (contentType && contentType.indexOf("application/json") !== -1) {
                        const responseData = await response.json();
                        // Changed from responseData.success to responseData.status === "success"
                        if (responseData.status === "success") { 
                            alert(responseData.message || '–°–æ–±—ã—Ç–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ!'); // Use message from backend
                            closeEventModal();
                            // Refresh timeline
                            if (selectedStartDate && timelineViewContainer) {
                                 const start = new Date(selectedStartDate);
                                 const end = selectedEndDate ? new Date(selectedEndDate) : new Date(selectedStartDate);
                                 generateTimelineView(start, end);
                            } else {
                                const today = new Date();
                                const currentMonth = today.getMonth();
                                const currentYear = today.getFullYear();
                                const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
                                const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);
                                generateTimelineView(firstDayOfMonth, lastDayOfMonth); // Refresh current month
                            }
                        } else {
                            // Display errors more gracefully inside the modal
                            let errorMessages = responseData.message || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ.';
                            if (responseData.errors) {
                                for (const field in responseData.errors) {
                                    errorMessages += `\n- ${field}: ${responseData.errors[field].join(', ')}`;
                                }
                            }
                            alert('–û—à–∏–±–∫–∞: ' + errorMessages);
                        }
                    } else {
                        // Handle non-JSON responses if necessary, or log an error
                        const textResponse = await response.text();
                        console.error("Server responded with non-JSON:", response.status, textResponse);
                        alert('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: –ø–æ–ª—É—á–µ–Ω –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
                    }
                } else {
                    // Handle HTTP errors (e.g., 400, 404, 500)
                    let errorText = '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.';
                    try {
                        const errorData = await response.json(); // Try to parse error as JSON
                        errorText = errorData.message || (errorData.errors ? JSON.stringify(errorData.errors) : errorText);
                         if (errorData.errors) {
                            let messages = [];
                            for (const field in errorData.errors) {
                                messages.push(`${field}: ${errorData.errors[field].join(', ')}`);
                            }
                            errorText = `–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø—Ä–∞–≤—å—Ç–µ –æ—à–∏–±–∫–∏: \n${messages.join('\n')}`;
                        } else if (errorData.message) {
                            errorText = errorData.message;
                        }
                    } catch (e) {
                        // If error response is not JSON, use default message or response.statusText
                        errorText = `–û—à–∏–±–∫–∞ ${response.status}: ${response.statusText}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.`;
                        console.error("Error parsing error response or non-JSON error response", e);
                    }
                    alert(errorText);
                }
            } catch (error) {
                console.error('Modal form submission error:', error);
                alert('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–æ—Ä–º—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å –¥–ª—è –¥–µ—Ç–∞–ª–µ–π.');
            }
        });
    }

    if (deleteEventModalButton) {
        deleteEventModalButton.addEventListener('click', async function() {
            const eventId = modalEventIdInput.value;
            if (!eventId) return;

            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ —Å–æ–±—ã—Ç–∏–µ?')) {
                try {
                    const response = await fetch(`/event/delete/${eventId}/`, {
                        method: 'POST', 
                        headers: {
                            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                            'Content-Type': 'application/json'
                        },
                    });

                    if (response.ok) {
                        const responseData = await response.json();
                        // Changed from responseData.success to responseData.status === "success"
                        if (responseData.status === "success") {
                            alert(responseData.message || '–°–æ–±—ã—Ç–∏–µ —É–¥–∞–ª–µ–Ω–æ!'); // Use message from backend
                            closeEventModal();
                            // Refresh timeline (same logic as after save)
                            if (selectedStartDate && timelineViewContainer) {
                                 const start = new Date(selectedStartDate);
                                 const end = selectedEndDate ? new Date(selectedEndDate) : new Date(selectedStartDate);
                                 generateTimelineView(start, end);
                            } else {
                               const today = new Date();
                                const currentMonth = today.getMonth();
                                const currentYear = today.getFullYear();
                                const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
                                const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);
                                generateTimelineView(firstDayOfMonth, lastDayOfMonth); // Refresh current month
                            }
                        } else {
                            alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏: ' + (responseData.message || '–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ.'));
                        }
                    } else {
                        const errorData = await response.json().catch(() => ({})); // Try to get JSON error or empty obj
                        alert('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏: ' + (errorData.message || `–ö–æ–¥ ${response.status}`));
                    }
                } catch (error) {
                    console.error('Delete event error:', error);
                    alert('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–±—ã—Ç–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å.');
                }
            }
        });
    }

    // --- Event Modal Open/Close Functions (NEW) ---
    function openEventModal() {
        if (eventModal) eventModal.style.display = 'flex';
    }

    function closeEventModal() {
        if (eventModal) eventModal.style.display = 'none';
        if (eventModalForm) eventModalForm.reset();
        if (modalEventIdInput) modalEventIdInput.value = ''; // Clear event ID
        if (deleteEventModalButton) deleteEventModalButton.style.display = 'none'; // Hide delete button
    }

    if (eventModalCloseButton) {
        eventModalCloseButton.addEventListener('click', closeEventModal);
    }
    if (cancelEventModalButton) {
        cancelEventModalButton.addEventListener('click', closeEventModal);
    }
    // Close modal if user clicks outside of modal-content (optional)
    window.addEventListener('click', (event) => {
        if (event.target === eventModal) { // Clicked on the modal backdrop
            closeEventModal();
        }
    });

    // --- Dynamic Loading for Friends and Chats --- 
    async function loadFriends() {
        if (!friendListContainer) return;
        friendListContainer.innerHTML = '<p class="placeholder-text">–ó–∞–≥—Ä—É–∑–∫–∞ –¥—Ä—É–∑–µ–π...</p>';
        try {
            // This URL should return JSON: [{id, username, profile_picture_url, ...}, ...]
            const response = await fetch("{% url 'friend_list_api' %}"); // IMPORTANT: Changed to 'friend_list_api'
            if (!response.ok) { throw new Error(`Network response was not ok for friends: ${response.status}`); }
            const friends = await response.json();

            friendListContainer.innerHTML = '';
            if (friends.length === 0) {
                friendListContainer.innerHTML = '<p class="placeholder-text">–î—Ä—É–∑–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.</p>';
                return;
            }
            friends.forEach(friend => {
                const item = document.createElement('div');
                item.classList.add('friend-item');
                item.innerHTML = `
                    <img src="${friend.profile_picture_url || defaultAvatarUrl}" alt="avatar" class="friend-avatar" onerror="this.src='${defaultAvatarUrl}'">
                    <div class="friend-info">
                        <span class="friend-name">${friend.username}</span>
                        <a href="{% url 'start_or_get_chat' 0 %}user_id=${friend.id}".replace('0?user_id=', friend.id + '?user_id=') class="friend-message-link">–ù–∞–ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ</a>
                    </div>
                    <button class="friend-options" data-friend-id="${friend.id}">‚ãÆ</button> 
                `; // TODO: Add actual options for friend-options button (e.g. remove friend)
                friendListContainer.appendChild(item);
            });
        } catch (error) {
            console.error("Failed to load friends:", error);
            friendListContainer.innerHTML = '<p class="placeholder-text" style="color:red;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥—Ä—É–∑–µ–π.</p>';
        }
    }

    async function loadChats() {
        if (!chatListContainer) return;
        chatListContainer.innerHTML = '<p class="placeholder-text">–ó–∞–≥—Ä—É–∑–∫–∞ —á–∞—Ç–æ–≤...</p>';
        try {
            // This URL should return JSON: [{id, name, last_message, last_message_at_display, participants:[{username, profile_picture_url}]}, ...]
            const response = await fetch("{% url 'chat_room_list_api' %}"); // IMPORTANT: Changed to 'chat_room_list_api'
            if (!response.ok) { throw new Error(`Network response was not ok for chats: ${response.status}`); }
            const chats = await response.json();
            
            chatListContainer.innerHTML = '';
            if (chats.length === 0) {
                chatListContainer.innerHTML = '<p class="placeholder-text">–ß–∞—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.</p>';
                return;
            }
            chats.forEach(chat => {
                let chatName = chat.name;
                let avatarUrl = defaultAvatarUrl; 
                let lastMessage = chat.last_message || '–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π';
                let lastMessageAt = chat.last_message_at_display || '';

                if (!chatName && chat.participants && chat.participants.length > 0) {
                    // For 1-on-1 chat, find the other participant (assuming current user is filtered out by API)
                    const otherParticipant = chat.participants[0]; // API should give the other user
                    if (otherParticipant) {
                        chatName = otherParticipant.username;
                        if(otherParticipant.profile_picture_url) avatarUrl = otherParticipant.profile_picture_url;
                    } else {
                         chatName = "–ß–∞—Ç"; // Fallback
                    }
                } else if (chat.participants && chat.participants.length > 1) { // Group chat
                    // Use first participant's avatar as group avatar or a generic one
                     if(chat.participants[0] && chat.participants[0].profile_picture_url) avatarUrl = chat.participants[0].profile_picture_url;
                }
                 if (!chatName) chatName = "–ì—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç";


                const item = document.createElement('div');
                item.classList.add('chat-item');
                // Correctly create chat room detail URL
                const chatDetailUrl = "{% url 'chat_room_detail' 0 %}".replace('0', chat.id);
                item.setAttribute('onclick', `window.location.href='${chatDetailUrl}'`);
                item.innerHTML = `
                    <img src="${avatarUrl}" alt="avatar" class="chat-avatar" onerror="this.src='${defaultAvatarUrl}'">
                    <div class="chat-info">
                        <span class="chat-name">${chatName}</span>
                        <span class="chat-last-message">${lastMessage}</span>
                    </div>
                    <span class="chat-time">${lastMessageAt}</span>
                `;
                chatListContainer.appendChild(item);
            });
        } catch (error) {
            console.error("Failed to load chats:", error);
            chatListContainer.innerHTML = '<p class="placeholder-text" style="color:red;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —á–∞—Ç–æ–≤.</p>';
        }
    }
    
    // --- Search Functionality for Left Panel ---
    if(friendSearchInput) {
        friendSearchInput.addEventListener('input', function() { // 'input' for live search
            const filter = this.value.toLowerCase();
            const items = friendListContainer.querySelectorAll('.friend-item');
            items.forEach(item => {
                const name = item.querySelector('.friend-name').textContent.toLowerCase();
                item.style.display = name.includes(filter) ? '' : 'none';
          });
        });
    }
     if(chatSearchInput) {
        chatSearchInput.addEventListener('input', function() { // 'input' for live search
            const filter = this.value.toLowerCase();
            const items = chatListContainer.querySelectorAll('.chat-item');
            items.forEach(item => {
                const name = item.querySelector('.chat-name').textContent.toLowerCase();
                item.style.display = name.includes(filter) ? '' : 'none';
        });
      });
    }

    // --- Initialize Page: Setup static parts like the new horizontal timeline header ---
    function initializePage() {
        if (smallCalendarDaysBodyEl) renderSmallCalendar();

        const timelineHeaderRow = document.getElementById('timelineHeader');
        if (timelineHeaderRow) {
            timelineHeaderRow.innerHTML = ''; 
            timelineHeaderRow.style.display = 'flex'; 
            timelineHeaderRow.style.boxSizing = 'border-box';

            // Add Month Title
            const monthTitleSpan = document.createElement('span');
            monthTitleSpan.classList.add('timeline-month-title');
            // Use currentSmallCalendarDate for consistency, or new Date() if timeline is independent
            monthTitleSpan.textContent = monthNames[currentSmallCalendarDate.getMonth()]; 
            timelineHeaderRow.appendChild(monthTitleSpan);

            const slotsContainer = document.createElement('div');
            slotsContainer.classList.add('timeline-header-slots-horizontal'); // New class for styling
            slotsContainer.style.position = 'relative'; // Crucial for mark positioning
            slotsContainer.style.width = '100%';      // Ensure it spans full width
            timelineHeaderRow.appendChild(slotsContainer);

            const timePoints = [
                { label: "06:00", percent: 0 },    // Start at 6:00 AM
                { label: "12:00", percent: 25 }, // Noon
                { label: "18:00", percent: 50 }, // 6 PM
                { label: "00:00", percent: 75 }, // Midnight
                { label: "06:00", percent: 100 }  // 6:00 AM next day (end of 24h cycle)
            ];

            timePoints.forEach(tp => {
                const mark = document.createElement('div');
                mark.classList.add('timeline-hour-mark-horizontal'); // New class
                mark.style.left = `${tp.percent}%`;

                const label = document.createElement('span');
                label.classList.add('timeline-hour-label-horizontal'); // New class
                label.textContent = tp.label;
                
                // Adjust label positioning to be centered under the mark, or at edges
                if (tp.percent === 0) {
                    label.style.transform = 'translateX(0%)'; // Consistent percentage unit
                } else if (tp.percent === 100) {
                    label.style.transform = 'translateX(-100%)';
                } else {
                    label.style.transform = 'translateX(-50%)';
                }

                mark.appendChild(label);
                slotsContainer.appendChild(mark);
            });
        }
        
        // Set initial selected range for small calendar and load vertical days
        const today = new Date();
        const dayOfWeek = today.getDay(); // 0 (Sun) - 6 (Sat)
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1)); // Adjust to Monday
        startOfWeek.setHours(0,0,0,0);

        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6);
        endOfWeek.setHours(23,59,59,999);

        selectedStartDate = getKrasnoyarskDateString(startOfWeek);
        selectedEndDate = getKrasnoyarskDateString(endOfWeek);
        
        if (smallCalendarDaysBodyEl) renderSmallCalendar();
        if (timelineViewContainer) generateTimelineView(startOfWeek, endOfWeek);
        // if (eventFormInline) updateEventFormForRange(selectedStartDate, selectedEndDate); // OLD Inline form logic - Call removed

        // Load initial tab content
        const activeTab = document.querySelector('.tab-link.active');
        if (activeTab) {
            const tabName = activeTab.getAttribute('onclick').match(/'([^']+)'/)[1];
            if (tabName === 'friends-tab-content') { loadFriends(); }
            else if (tabName === 'chats-tab-content') { loadChats(); }
        } else { // Fallback if no tab is active by default (should be one)
            loadFriends();
        }
        
        // Fetch friend request count
        fetch("{% url 'friend_requests_count_api' %}") // Needs a new API endpoint
            .then(response => response.json())
            .then(data => {
                const badge = document.getElementById('friendRequestsCount');
                if (badge && data.count > 0) {
                    badge.textContent = data.count;
                    badge.style.display = 'inline-block';
                } else if (badge) {
                    badge.style.display = 'none';
                }
            })
            .catch(err => console.error('Failed to fetch friend request count:', err));
    }

    initializePage();
    });
  </script>
{% endblock %}
